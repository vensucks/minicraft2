<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MiniCraft 3D — Fixed World</title>
<style>
/* Basic reset and pixel-like UI */
html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Arial, Helvetica, sans-serif}
canvas{display:block}
#dirt{position:fixed;inset:0;z-index:1;image-rendering:pixelated;pointer-events:none}
#ui{position:fixed;inset:0;z-index:3;pointer-events:none}
.menu{width:460px;margin:6vh auto 0 auto;background:rgba(8,8,8,0.8);border:6px solid rgba(255,255,255,0.04);padding:16px;border-radius:8px;text-align:center;color:#fff;pointer-events:auto}
.logo{font-size:56px;font-weight:900;color:#f6e07a;text-shadow:0 8px 12px rgba(0,0,0,0.6);letter-spacing:4px;margin-bottom:6px}
.btn{display:inline-block;width:220px;padding:10px 12px;margin:8px;border-radius:6px;border:4px solid rgba(0,0,0,0.45);background:linear-gradient(180deg,#e7df78,#bfb04a);color:#07210a;font-weight:800;cursor:pointer;pointer-events:auto}
.btn.secondary{background:linear-gradient(180deg,#dadada,#bdbdbd);color:#111}
.small{color:#ddd;font-size:13px;margin-top:6px}
.worldMenu{display:none;pointer-events:auto;width:560px;margin:6vh auto 0 auto;background:rgba(6,6,6,0.85);padding:14px;border-radius:8px}
.inputRow{display:flex;gap:8px;align-items:center;margin-top:8px}
.hotbar{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;display:flex;gap:8px;pointer-events:auto;z-index:5}
.slot{width:56px;height:56px;background:rgba(0,0,0,0.45);border:3px solid rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900;border-bottom-width:8px;border-radius:6px}
.slot.sel{transform:translateY(-4px);outline:4px solid rgba(255,255,255,0.06)}
.invPanel{position:fixed;right:18px;top:18px;width:340px;background:rgba(6,6,6,0.9);padding:12px;border-radius:8px;display:none;pointer-events:auto;z-index:6;color:#fff}
.invGrid{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}
.invSlot{height:56px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;border-radius:6px}
.hint{position:fixed;left:18px;bottom:18px;background:rgba(255,255,255,0.95);color:#07210a;padding:8px 12px;border-radius:8px;pointer-events:auto;z-index:6}
.toast{position:fixed;left:50%;top:12px;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:#fff;padding:8px 12px;border-radius:8px;display:none;z-index:8}
@media (max-width:540px){ .menu{width:90%}.logo{font-size:40px}.slot{width:44px;height:44px} }
</style>
</head>
<body>
<canvas id="gl"></canvas>
<canvas id="dirt"></canvas>
<div id="ui">
  <div id="mainMenu" class="menu">
    <div class="logo">MINICRAFT</div>
    <div class="small">Single-file demo — fixed-size world, biomes, clouds, day/night</div>
    <div style="margin-top:12px">
      <button class="btn" id="btnSingle">Singleplayer</button>
      <button class="btn secondary" id="btnOptions">Options</button>
      <button class="btn" id="btnQuit">Quit</button>
    </div>
    <div class="small">Click Singleplayer to create a new world.</div>
  </div>

  <div id="worldMenu" class="worldMenu">
    <div style="display:flex;align-items:center;gap:12px">
      <div style="font-size:28px;font-weight:800">Create New World</div>
    </div>
    <div class="small" style="margin-top:6px">Customize size & seed</div>
    <div class="inputRow">
      <label style="width:50px;color:#fff">Seed</label>
      <input id="seed" placeholder="leave blank for random" style="flex:1;padding:8px;border-radius:6px;border:none" />
      <button class="btn secondary" id="rand">Random</button>
    </div>
    <div class="inputRow">
      <label style="width:50px;color:#fff">Size</label>
      <select id="size" style="padding:8px;border-radius:6px">
        <option value="32">Small (32)</option>
        <option value="64" selected>Medium (64)</option>
        <option value="96">Large (96)</option>
      </select>
      <div style="flex:1"></div>
      <button class="btn" id="create">Create</button>
      <button class="btn secondary" id="cancel">Back</button>
    </div>
  </div>

  <div id="hotbar" class="hotbar" style="display:none"></div>
  <div id="invPanel" class="invPanel"></div>
  <div id="hint" class="hint">Click to lock mouse • WASD • LMB remove • RMB place • E inventory</div>
  <div id="toast" class="toast"></div>
</div>

<script type="module">
// Single-file MiniCraft fixed-size — Three.js from CDN
import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
import { BufferGeometryUtils } from 'https://unpkg.com/three@0.158.0/examples/jsm/utils/BufferGeometryUtils.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/PointerLockControls.js';

const canvas = document.getElementById('gl');
const dirt = document.getElementById('dirt');
const toast = document.getElementById('toast');
let renderer, scene, camera, controls;
let merged = {};
let world = new Map();
const blockTypes = ['grass','dirt','sand','stone','water'];
let inventory = {'dirt':40,'grass':12,'sand':30,'stone':6};
let selected = 0;
let worldSize = 64;
let seedVal = Math.floor(Math.random()*999999).toString();

// --- Dirt background (scrolling) ---
const dctx = dirt.getContext('2d');
let patternCanvas = document.createElement('canvas');
patternCanvas.width = patternCanvas.height = 64;
function buildDirt(){
  const ctx = patternCanvas.getContext('2d');
  ctx.fillStyle='#8b5a30'; ctx.fillRect(0,0,64,64);
  ctx.fillStyle='#b88f42'; ctx.fillRect(0,0,64,10);
  for(let i=0;i<200;i++){ ctx.fillStyle='rgba(0,0,0,'+ (Math.random()*0.08) +')'; ctx.fillRect(Math.random()*64,Math.random()*64,1,1); }
}
let dirtOffset=0;
function resizeDirt(){
  dirt.width = Math.ceil(window.innerWidth/2);
  dirt.height = Math.ceil(window.innerHeight/2);
  buildDirt(); drawDirt();
}
function drawDirt(){
  dctx.clearRect(0,0,dirt.width,dirt.height);
  dctx.save();
  dctx.translate(0, Math.floor(dirtOffset%64));
  const pat = dctx.createPattern(patternCanvas,'repeat');
  dctx.fillStyle = pat;
  dctx.fillRect(0,-64,dirt.width,dirt.height+64);
  dctx.restore();
}
let last = performance.now();
function dirtLoop(){
  const now = performance.now(); const dt=(now-last)/1000; last=now;
  dirtOffset += dt*12;
  drawDirt();
  requestAnimationFrame(dirtLoop);
}
window.addEventListener('resize', ()=>{ renderer && renderer.setSize(window.innerWidth,window.innerHeight); resizeDirt(); });

// --- Simple noise-based world with biomes ---
function mulberry32(a){ return function(){ a |= 0; a = a + 0x6D2B79F5 | 0; var t = Math.imul(a ^ a >>> 15, 1 | a); t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
function noise(nx, nz, rng){
  // combine sines for cheap noise-like pattern
  return (Math.sin(nx*1.7 + nz*0.5)*0.5 + Math.cos(nz*1.5 - nx*0.3)*0.5);
}
function generateWorld(size, seed){
  world.clear();
  const seedNum = Number(String(seed).split('').reduce((a,c)=>a+ c.charCodeAt(0),0)) || Number(seed);
  const rng = mulberry32(seedNum);
  const scale = 0.08;
  for(let x=-size/2;x<size/2;x++){
    for(let z=-size/2;z<size/2;z++){
      const n = (noise(x*scale, z*scale, rng)+1)/2;
      const height = Math.max(0, Math.floor(n*7)+1);
      // determine biome: low height near edges -> sand, very low -> water
      const biomeRoll = (noise(x*scale*2,z*scale*2,rng)+1)/2;
      let col = 'dirt';
      if(height <= 1) col = 'water';
      else if(height <= 2) col = 'sand';
      else if(height >= 6) col = 'stone';
      else col = (biomeRoll>0.55)?'grass':'dirt';
      world.set(`${x},${z}`, {h:height, top:col});
    }
  }
  rebuildAll();
}

// --- Three.js scene & merged geometry ---
function initThree(){
  renderer = new THREE.WebGLRenderer({canvas:canvas, antialias:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0,8,16);
  const amb = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(amb);
  const sun = new THREE.DirectionalLight(0xffffff, 0.9);
  sun.position.set(5,20,10);
  sun.castShadow = false;
  scene.add(sun);
  scene.userData.sun = sun;
  controls = new PointerLockControls(camera, renderer.domElement);
  scene.add(controls.getObject());
  // simple ground collider
  const plane = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshBasicMaterial({visible:false}));
  plane.rotation.x = -Math.PI/2; plane.position.y = -10;
  scene.add(plane);
  window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); resizeDirt(); });
}

function makeMat(type){
  const c = document.createElement('canvas'); c.width=c.height=32;
  const ctx = c.getContext('2d');
  if(type==='grass'){ ctx.fillStyle='#5ea84a'; ctx.fillRect(0,0,32,32); ctx.fillStyle='#6fc85a'; ctx.fillRect(0,0,6,32); }
  else if(type==='dirt'){ ctx.fillStyle='#8b5a30'; ctx.fillRect(0,0,32,32); }
  else if(type==='sand'){ ctx.fillStyle='#d9c07a'; ctx.fillRect(0,0,32,32); }
  else if(type==='stone'){ ctx.fillStyle='#9a9a9a'; ctx.fillRect(0,0,32,32); }
  else if(type==='water'){ ctx.fillStyle='#3b87c9'; ctx.fillRect(0,0,32,32); }
  for(let i=0;i<90;i++){ ctx.fillStyle='rgba(0,0,0,'+(Math.random()*0.06)+')'; ctx.fillRect(Math.random()*32,Math.random()*32,1,1); }
  const tex = new THREE.CanvasTexture(c); tex.magFilter = THREE.NearestFilter; tex.minFilter = THREE.LinearMipMapLinearFilter;
  return new THREE.MeshLambertMaterial({map:tex});
}

function rebuildAll(){
  // remove old merged meshes
  for(const k in merged) scene.remove(merged[k]);
  merged = {};
  const geoms = {};
  const types = ['grass','dirt','sand','stone','water'];
  for(const t of types) geoms[t] = [];
  const cube = new THREE.BoxGeometry(1,1,1);
  for(const [k,v] of world){
    const [x,z] = k.split(',').map(Number);
    for(let y=0;y<v.h;y++){
      let type = (y===v.h-1)?v.top:'dirt';
      // create cube geometry placed at x,y,z
      const g = cube.clone();
      g.translate(x, y, z);
      geoms[type].push(g);
    }
    // water layer for low spots (if top is water, fill up to 2)
    if(v.top==='water'){
      const g = cube.clone(); g.translate(x, 0, z); geoms['water'].push(g);
    }
  }
  const mats = {};
  types.forEach(t=>mats[t]=makeMat(t));
  for(const t of types){
    if(geoms[t].length===0) continue;
    const mergedGeo = BufferGeometryUtils.mergeBufferGeometries(geoms[t], false);
    const mesh = new THREE.Mesh(mergedGeo, mats[t]);
    mesh.frustumCulled = true;
    scene.add(mesh);
    merged[t]=mesh;
  }
}

// --- Interaction & UI wiring ---
const btnSingle = document.getElementById('btnSingle');
const btnOptions = document.getElementById('btnOptions');
const btnQuit = document.getElementById('btnQuit');
const mainMenu = document.getElementById('mainMenu');
const worldMenu = document.getElementById('worldMenu');
const randBtn = document.getElementById('rand');
const createBtn = document.getElementById('create');
const cancelBtn = document.getElementById('cancel');
const seedInput = document.getElementById('seed');
const sizeSelect = document.getElementById('size');
const hotbarEl = document.getElementById('hotbar');
const invPanel = document.getElementById('invPanel');
const hint = document.getElementById('hint');

btnSingle.onclick = ()=>{ mainMenu.style.display='none'; worldMenu.style.display='block'; worldMenu.scrollIntoView(); };
btnOptions.onclick = ()=> showToast('Options not implemented.');
btnQuit.onclick = ()=> showToast('Close the tab to quit.');
randBtn.onclick = ()=> seedInput.value = String(Math.floor(Math.random()*999999));
cancelBtn.onclick = ()=>{ worldMenu.style.display='none'; mainMenu.style.display='block'; };

createBtn.onclick = ()=>{
  worldSize = Number(sizeSelect.value);
  seedVal = seedInput.value || String(Math.floor(Math.random()*999999));
  worldMenu.style.display='none';
  startGame();
};

function showToast(msg){ toast.style.display='block'; toast.textContent=msg; setTimeout(()=>toast.style.display='none',1500); }

// --- Hotbar & inventory UI ---
function buildHotbar(){
  hotbarEl.innerHTML=''; const types = ['dirt','grass','sand','stone','water'];
  for(let i=0;i<9;i++){
    const s = document.createElement('div'); s.className='slot'; s.textContent = types[i%types.length].charAt(0).toUpperCase();
    if(i===selected) s.classList.add('sel');
    s.addEventListener('click', ()=> selectSlot(i));
    hotbarEl.appendChild(s);
  }
  hotbarEl.style.display='none';
}

function selectSlot(i){ selected=i; document.querySelectorAll('.slot').forEach((el,idx)=> el.classList.toggle('sel', idx===selected)); }

function buildInv(){
  invPanel.innerHTML = '<h3 style="margin:0 0 8px 0">Inventory</h3>';
  const grid = document.createElement('div'); grid.className='invGrid';
  const types = ['dirt','grass','sand','stone','water'];
  for(let i=0;i<10;i++){ const d = document.createElement('div'); d.className='invSlot'; const t=types[i%types.length]; d.textContent = t + ' x' + (inventory[t]||0); grid.appendChild(d); }
  invPanel.appendChild(grid);
  const close = document.createElement('div'); close.style.marginTop='8px'; close.innerHTML = '<button class="btn secondary" id="closeInv">Close</button>'; invPanel.appendChild(close);
  document.getElementById('closeInv').onclick = ()=> invPanel.style.display='none';
}

// --- Start game flow ---
let moving = {f:0,b:0,l:0,r:0}, vel = new THREE.Vector3(), canJump=true;
function setupInput(){
  document.addEventListener('keydown',(e)=>{ if(e.code==='KeyW') moving.f=1; if(e.code==='KeyS') moving.b=1; if(e.code==='KeyA') moving.l=1; if(e.code==='KeyD') moving.r=1; if(e.code==='Space'&&canJump){ vel.y=6; canJump=false;} if(e.code==='KeyE') invPanel.style.display = invPanel.style.display==='none'?'block':'none'; if(e.code.startsWith('Digit')) selectSlot(Number(e.code.slice(5))-1); if(e.code==='Escape'){ controls.unlock(); mainMenu.style.display='block'; hotbarEl.style.display='none'; hint.style.display=''; } });
  document.addEventListener('keyup',(e)=>{ if(e.code==='KeyW') moving.f=0; if(e.code==='KeyS') moving.b=0; if(e.code==='KeyA') moving.l=0; if(e.code==='KeyD') moving.r=0; });

  renderer.domElement.addEventListener('click', ()=>{
    if(!controls.isLocked){ controls.lock(); hint.style.display='none'; }
  });

  const ray = new THREE.Raycaster();
  window.addEventListener('mousedown', (e)=>{
    if(!controls.isLocked) return;
    ray.setFromCamera(new THREE.Vector2(0,0), camera);
    const list = Object.values(merged);
    const hits = ray.intersectObjects(list, true);
    if(hits.length>0){
      const hit = hits[0]; const pt = hit.point; const nrm = hit.face.normal;
      const colX = Math.round(pt.x), colZ = Math.round(pt.z);
      if(e.button===0){ // remove top block in column
        removeAt(colX,colZ);
      } else if(e.button===2){ // place block on top if inventory available
        placeAt(colX,colZ);
      }
    }
  });
  window.addEventListener('contextmenu', e=>e.preventDefault());
}

function removeAt(x,z){ const k = `${x},${z}`; const val = world.get(k); if(!val) return; if(val.h>0){ val.h--; inventory['dirt'] = (inventory['dirt']||0)+1; world.set(k,val); rebuildAll(); buildInv(); showToast('Removed block'); } }
function placeAt(x,z){ const k=`${x},${z}`; const val = world.get(k) || {h:0,top:'dirt'}; if(inventory['dirt']>0){ val.h++; world.set(k,val); rebuildAll(); buildInv(); inventory['dirt']--; showToast('Placed block'); } else showToast('No dirt'); }

// --- Day / night cycle and clouds ---
let dayTime = 0; const clouds = [];
function setupDayNight(){
  // create clouds as transparent planes
  const cloudMat = new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.9});
  for(let i=0;i<12;i++){
    const geo = new THREE.PlaneGeometry(12,6);
    const mesh = new THREE.Mesh(geo, cloudMat.clone());
    mesh.position.set( (Math.random()-0.5)*worldSize, 30 + Math.random()*6, (Math.random()-0.5)*worldSize );
    mesh.rotation.y = Math.random()*Math.PI*2;
    mesh.material.opacity = 0.85; scene.add(mesh); clouds.push(mesh);
  }
}

// --- Game loop ---
let prev = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now(); const dt = (now-prev)/1000; prev=now;
  // day/night
  dayTime += dt*0.02;
  const sun = scene.userData.sun;
  const angle = dayTime * Math.PI * 2;
  sun.position.set(Math.cos(angle)*20, Math.sin(angle)*20, 10);
  const intensity = Math.max(0.2, Math.sin(angle)*0.9 + 0.2);
  sun.intensity = intensity;
  scene.background = new THREE.Color().setHSL(0.6, 0.7, Math.max(0.2, 0.6*intensity));
  // clouds movement
  clouds.forEach((c,i)=>{ c.position.x += dt*0.8; if(c.position.x > worldSize) c.position.x = -worldSize; });
  // movement physics
  if(controls && controls.isLocked){
    vel.x -= vel.x*10*dt; vel.z -= vel.z*10*dt; vel.y -= 9.8*2*dt;
    const dir = new THREE.Vector3(moving.r-moving.l, 0, moving.f-moving.b);
    if(dir.length()>0){ dir.normalize(); vel.x -= dir.x*5*dt; vel.z -= dir.z*5*dt; }
    controls.moveRight(-vel.x*dt); controls.moveForward(-vel.z*dt);
    controls.getObject().position.y += vel.y*dt;
    if(controls.getObject().position.y < 2){ vel.y = 0; controls.getObject().position.y = 2; canJump=true; }
  }
  renderer.render(scene, camera);
}

// --- Start everything ---
function startGame(){
  initThree();
  buildHotbar();
  buildInv();
  setupInput();
  generateWorld(worldSize, seedVal);
  setupDayNight();
  document.getElementById('hotbar').style.display='flex';
  document.getElementById('hint').style.display='none';
  animate(); dirtLoop();
  showToast('Seed: '+seedVal);
}

function initThree(){
  initThreeCalled = true;
  initThreeInner();
}
let initThreeCalled = false;
function initThreeInner(){
  initThree(); // recursive placeholder, but we'll actually set up below
}

// actual Three init function implementation to avoid earlier name conflict
function initThree(){
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5));
  document.body.appendChild(renderer.domElement);
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0,8,16);
  const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
  const sun = new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(5,20,10); scene.add(sun); scene.userData.sun = sun;
  controls = new PointerLockControls(camera, renderer.domElement); scene.add(controls.getObject());
  // simple invisible floor
  const floor = new THREE.Mesh(new THREE.BoxGeometry(200,1,200), new THREE.MeshBasicMaterial({visible:false}));
  floor.position.y = -10; scene.add(floor);
  window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); resizeDirt(); });
}

// To avoid name collision, call initThreeInner assignment earlier is fine
// --- End of init functions ---

// Actually wire start button to create small world
document.getElementById('btnSingle').addEventListener('click', ()=>{ mainMenu.style.display='none'; worldMenu.style.display='block'; });
document.getElementById('create').addEventListener('click', ()=>{ worldSize = Number(sizeSelect.value); seedVal = seedInput.value || String(Math.floor(Math.random()*999999)); worldMenu.style.display='none'; // initialize three, clouds, UI, world
  initThree(); buildHotbar(); buildInv(); setupInput(); generateWorld(worldSize, seedVal); setupDayNight(); document.getElementById('hotbar').style.display='flex'; animate(); dirtLoop(); showToast('Seed: '+seedVal); });

// small helpers
function showToast(msg){ const t = document.getElementById('toast'); t.style.display='block'; t.textContent=msg; setTimeout(()=>t.style.display='none',1400); }

// initial UI setup
buildHotbar();
buildInv();
resizeDirt();
drawDirt();
dirtLoop();

</script>
</body>
</html>
